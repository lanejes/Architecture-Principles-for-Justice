#Principles

[Keep it simple](#keep-it-simple)
[Emergent design over upfront design](#emergent-design-over-upfront-design)
[High-level long-term options over detailed long-term design](#High-level-long-term-options-over-detailed-long-term-design)
[Shared services over shared code](#Shared-services-over-shared-code)
[Know the limitations of your architecture](#Know-the-limitations-of-your-architecture)
[Microservices over monoliths](#Microservices-over-monoliths)
[Composability over all-in-one systems](#Composability-over-all-in-one-systems)
[Cooperative architecture over siloed architecture](#Cooperative-architecture-over-siloed-architecture)
[Data services over databases](#Data-services-over-databases)
[Boundaries of responsibility over shared ownership](#Boundaries-of-responsibility-over-shared-ownership)
[REST over RPC](#REST-over-RPC)
[Requesting data over sending data](#Requesting-data-over-sending-data)
[Dumb pipes and intelligent endpoints over middleware](#Dumb-pipes-and-intelligent-endpoints-over-middleware)
[Presume service failure over trusting service availability](#Presume-service-failure-over-trusting-service-availability)
[Open-source over closed-source](#Open-source-over-closed-source)
[Open Standards over Proprietary Standards]
[Modern browser interfaces by default]
[Public cloud by default]
[Continuous delivery over change management]
[Trust but verify code]
[Automation over manual intervention]
[Secure systems over secure zones]










##Keep it simple

Software systems are never ‘done’. We should always be in a position to update and improve any information system in justice. If we are able to change systems, we negate the advantages of so-called ‘future-proofing’: adding features to anticipate the result of decisions that have not yet been made. 

